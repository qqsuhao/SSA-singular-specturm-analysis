<span id="mulu">目录</span>
>[第二章 SSA基础](#index2)
>>[2.1 基础算法](#index2.1)
>>>[2.1.1 算法描述](#index2.1.1)
>>>>[2.1.1.1 第一阶段：分解](#index2.1.1.1)
>>>>
>>>>[2.1.1.2 第二阶段：重构](#index2.1.1.2)
>>>
>>>[2.1.2 对SSA基础算法中四个步骤的分析](#index2.1.2)



---
# <span id="index2">第二章 SSA基础</span> [目录](#mulu)
## <span id="index2.1"> 2.1 基础算法</span> [目录](#mulu)
### <span id="index2.1.1">2.1.1 算法描述</span> [目录](#mulu)

考虑一个长度为$N$的时间序列$\mathbb{X}=\mathbb{X}_{N}=\left(x_{1}, \ldots, x_{N}\right)$。假设$N>2$且$\mathbb{X}$是一个非零序列。用$L(1<L<N)$表示窗口长度，并且$K=N-L+1$。下面将讲述SSA的基础算法，其中包含两个阶段：分解和重构。

#### <span id="index2.1.1.1">2.1.1.1 第一阶段：分解</span> [目录](#mulu)
**第一步：嵌入**

我们将原始序列映射为长度为$L$的$K=N-L+1$个滞后向量，称其为L-滞后向量。
$$
X_{i}=\left(x_{i}, \ldots, x_{i+L-1}\right)^{\mathrm{T}} \quad(1 \leq i \leq K)
$$
由L-滞后向量组成L-轨迹矩阵：
<span id="eq2.1"></span>
$$
\mathbf{X}=\left[X_{1}: \ldots: X_{K}\right]=\left(x_{i j}\right)_{i, j=1}^{L, K}=\left(\begin{array}{llll}
x_{1} & x_{2} & x_{3} & \ldots x_{K} \\
x_{2} & x_{3} & x_{4} & \ldots x_{K+1} \\
x_{3} & x_{4} & x_{5} & \ldots x_{K+2} \\
\vdots & \vdots & \vdots & \ddots \\
x_{L} & x_{L+1} & x_{L+2} & \ldots x_{N}
\end{array}\right)  \tag{2.1} 
$$
滞后向量$X_{i}$是**轨迹矩阵**$\mathbf{X}$的列。$\mathbf{X}$的行和列都是原序列的子序列。$\mathbf{X}$中的位于$(i,j)$的元素$x_{ij}=x_{i+j-1}$，因此$\mathbf{X}$中反对角线的元素相等。（因此轨迹矩阵也被称称作**汉克尔矩阵**）
公式[(2.1)](#eq2.1)定义了一个从时间序列到轨迹矩阵的一对一的映射。


**第二步：奇异值分解**
在这一步，我们对$\mathbf{X}$进行SVD分解。令$\mathbf{S}=\mathbf{X}\mathbf{X}^{T}$并且用$\lambda_{1}, \ldots, \lambda_{L}$表示$\mathbf{S}$的特征值，其中这些特征值按照从大到小的顺序排列。用$U_{1}, \ldots, U_{L}$表示对应的特征向量。
用$d$表示矩阵$\mathbf{X}$的秩，一般情况下，如果时间序列是真实世界中获取到的，$d=L^*=min{L,K}$。记$V_{i}=\mathbf{X}^{\mathrm{T}} U_{i} / \sqrt{\lambda_{i}}(i=1, \ldots, d)$。轨迹矩阵$\mathbf{X}$可以被分解为：
<span id="eq2.2"></span>
$$
\mathbf{X}=\mathbf{X}_{1}+\ldots+\mathbf{X}_{d}  \tag{2.2}
$$
其中$\mathbf{X}_{i}=\sqrt{\lambda_{i}} U_{i} V_{i}^{\mathrm{T}}$。
矩阵$\mathbf{X}_{i}$的秩为1，这样的矩阵被称作初等矩阵（elementary matrices），
集合$\left(\sqrt{\lambda_{i}}, U_{i}, V_{i}\right)$被称作三特征（eigentriple）简记作ET。


#### <span id="index2.1.1.2">2.1.1.2 第二阶段：重构</span> [目录](#mulu)
**第三步：三特征分组**
一旦得到[(2.2)](#eq2.2)的分解结果，就把$d$个分解结果分配到$m$个不相交的子集中$I_{1}, \ldots, I_{m}$。令$I=\left\{i_{1}, \ldots, i_{p}\right\}$。
分组$I$对应的分组结果$\mathbf{X}_{I}=\mathbf{X}_{i_1}+...+\mathbf{X}_{i_p}$。
最终分组后的结果记为
<span id="eq2.3"></span>
$$
\mathbf{X}=\mathbf{X}_{I_{1}}+\ldots+\mathbf{X}_{I_{m}} \tag{2.3}
$$
挑选集合$I_{1}, \ldots, I_{m}$的过程称作三特征分组，如果$m=d$，即$I_{j}=\{j\}, j=1, \ldots, d$，则该分组成为初等分组。


**第四步：对角平均**
在这一步，我们需要把矩阵$\mathbf{X}_{I_{j}}$还原为时间序列。
令$\mathbf{Y}$表示$L*K$的一个矩阵，记$L^*=min(L, K), K^*=max(L,K)，N=L+K-1$。
令$y_{i j}^{*}=y_{i j}$如果$L<K$，否则$y_{i j}^{*}=y_{j i}$。
使用以下公式将矩阵$\mathbf{Y}$还原为时间序列：
<span id="eq2.4"></span>
$$
y_{k}= \begin{cases}\frac{1}{k} \sum_{m=1}^{k} y_{m, k-m+1}^{*} & \text { for } 1 \leq k<L^{*}, \\ \frac{1}{L^{*}} \sum_{m=1}^{L^{*}} y_{m, k-m+1}^{*} & \text { for } L^{*} \leq k \leq K^{*}, \\ \frac{1}{N-k+1} \sum_{m=k-K^{*}+1}^{N-K^{*}+1} y_{m, k-m+1}^{*} & \text { for } K^{*}<k \leq N .\end{cases}
\tag{2.4}
$$
该公式对应着求取矩阵反对角线元素的平均值。

对$\mathbf{X}_{I_{k}}$使用对角平均可以得到重构序列$\tilde{\mathrm{X}}^{(k)}=\left(\tilde{x}_{1}^{(k)}, \ldots, \tilde{x}_{N}^{(k)}\right)$。最终，初始序列被分解为$m$成分：
<span id="eq2.5"></span>
$$
x_{n}=\sum_{k=1}^{m} \tilde{x}_{n}^{(k)} \quad(n=1,2, \ldots, N)    \tag{2.5}
$$
由初等分组得到的序列重构结果被称作初等重构序列（elementary reconstructed series）。

**Remark 2.1** 基础SSA算法可以自然扩展到复数时间序列：唯一的区别在于矩阵的转置要替换为复数的共轭转置。


### <span id="index2.1.2">2.1.2 对SSA基础算法中四个步骤的分析 [目录](#mulu)
